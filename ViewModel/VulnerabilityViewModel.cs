using GalaSoft.MvvmLight;
using GalaSoft.MvvmLight.Command;
using GalaSoft.MvvmLight.Messaging;
using LiveCharts;
using LiveCharts.Defaults;
using LiveCharts.Wpf;
using log4net;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.SQLite;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Vulnerator.Model.BusinessLogic;
using Vulnerator.Model.DataAccess;
using Vulnerator.Model.Object;
using Vulnerator.ViewModel.ViewModelHelper;

namespace Vulnerator.ViewModel
{
    public class VulnerabilityViewModel : ViewModelBase
    {
        public string[] Labels { get; set; }
        public SeriesCollection ColumnSeriesCollection { get; set; }
        public SeriesCollection AreaSerisCollection { get; set; }
        public List<int> Values { get; set; }
        public Func<double, string> Formatter { get; set; }
        public Func<double, string> DateFormatter { get; set; }
        OpenFileDialog openFileDialog;
        private SaveFileDialog saveExcelFile;
        private SaveFileDialog savePdfFile;
        private BackgroundWorker backgroundWorker;
        private static readonly ILog log = LogManager.GetLogger(typeof(Logger));
        public static Stopwatch stopWatch = new Stopwatch();
        public static Stopwatch fileStopWatch = new Stopwatch();
        private DatabaseInterface databaseInterface = new DatabaseInterface();

        private List<Vulnerability> _vulnerabilityList;
        public List<Vulnerability> VulnerabilityList
        {
            get { return _vulnerabilityList; }
            set
            {
                if (_vulnerabilityList != value)
                {
                    _vulnerabilityList = value;
                    RaisePropertyChanged("VulnerabilityList");
                }
            }
        }

        private AsyncObservableCollection<string> _supportedFileTypes;
        public AsyncObservableCollection<string> SupportedFileTypes
        {
            get { return _supportedFileTypes; }
            set
            {
                if (_supportedFileTypes != value)
                {
                    _supportedFileTypes = value;
                    RaisePropertyChanged("SupportedFileTypes");
                }
            }
        }

        private AsyncObservableCollection<Model.Object.File> _ingestedFiles;
        public AsyncObservableCollection<Model.Object.File> IngestedFiles
        {
            get { return _ingestedFiles; }
            set
            {
                if (_ingestedFiles != value)
                {
                    _ingestedFiles = value;
                    RaisePropertyChanged("IngestedFiles");
                }
            }
        }

        public VulnerabilityViewModel()
        {
            _vulnerabilityList = PopulateVulnerabilityList(1000);
            SetTrendSeries();
            SupportedFileTypes = new AsyncObservableCollection<string>();
            IngestedFiles = new AsyncObservableCollection<Model.Object.File>();
            PopulateSupportedFileTypes();
        }

        private void PopulateSupportedFileTypes()
        {
            string[] fileTypes = new string[] { "ACAS", "CKL", "Fortify", "XCCDF", "WASSP" };
            foreach (string fileType in fileTypes)
            { SupportedFileTypes.Add("Import " + fileType); }
        }

        private List<Vulnerability> PopulateVulnerabilityList(int dataPoints)
        {
            List<Vulnerability> vulnerabilityList = new List<Vulnerability>();
            string[] rawRisks = new string[] { "I", "II", "III", "IV" };
            Random random = new Random();
            for (int i = 0; i < dataPoints; i++)
            {
                int age = random.Next(0, 90);
                DateTime lastObserved = DateTime.Now.AddDays(-age);
                int rawRiskIndex = random.Next(0, 4);
                vulnerabilityList.Add(new Vulnerability(rawRisks[rawRiskIndex], lastObserved));
            }
            vulnerabilityList = vulnerabilityList.OrderBy(v => v.LastObserved).ToList();
            return vulnerabilityList;
        }

        private void SetTrendSeries()
        {
            ColumnSeriesCollection = new SeriesCollection
            {
                new ColumnSeries
                {
                    Title = "CAT I",
                    Values = new ChartValues<double>
                    { VulnerabilityList.Count(v => v.RawRisk == "I") }
                },
                new ColumnSeries
                {
                    Title = "CAT II",
                    Values = new ChartValues<double>
                    { VulnerabilityList.Count(v => v.RawRisk == "II") }
                },
                new ColumnSeries
                {
                    Title = "CAT III",
                    Values = new ChartValues<double>
                    { VulnerabilityList.Count(v => v.RawRisk == "III") }
                },
                new ColumnSeries
                {
                    Title = "CAT IV",
                    Values = new ChartValues<double>
                    { VulnerabilityList.Count(v => v.RawRisk == "IV") }
                }
            };
            Formatter = value => value.ToString();

            StackedAreaSeries catI = new StackedAreaSeries
            {
                Title = "CAT I",
                Values = new ChartValues<DateTimePoint>()
            };
            StackedAreaSeries catII = new StackedAreaSeries
            {
                Title = "CAT II",
                Values = new ChartValues<DateTimePoint>()
            };
            StackedAreaSeries catIII = new StackedAreaSeries
            {
                Title = "CAT III",
                Values = new ChartValues<DateTimePoint>()
            };
            StackedAreaSeries catIV = new StackedAreaSeries
            {
                Title = "CAT IV",
                Values = new ChartValues<DateTimePoint>()
            };
            var grouped = VulnerabilityList.GroupBy(x => new { x.LastObserved, x.RawRisk } );
            foreach (var item in grouped)
            {
                int day = item.Key.LastObserved.Day;
                int month = item.Key.LastObserved.Month;
                int year = item.Key.LastObserved.Year;
                if (item.Key.RawRisk.Equals("I"))
                { catI.Values.Add(new DateTimePoint(new DateTime(year, month, day), item.Count())); }
                else if (item.Key.RawRisk.Equals("II"))
                { catII.Values.Add(new DateTimePoint(new DateTime(year, month, day), item.Count())); }
                else if (item.Key.RawRisk.Equals("III"))
                { catIII.Values.Add(new DateTimePoint(new DateTime(year, month, day), item.Count())); }
                else
                { catIV.Values.Add(new DateTimePoint(new DateTime(year, month, day), item.Count())); }
            }
            AreaSerisCollection = new SeriesCollection { catI, catII, catIII, catIV };
            DateFormatter = val => new DateTime((long)val).ToShortDateString();
        }

        public RelayCommand<object> IngestFilesCommand
        { get { return new RelayCommand<object>((p) => IngestFiles(p)); } }

        private void IngestFiles(object parameter)
        {
            if (openFileDialog != null)
            { openFileDialog = null; }
            openFileDialog = new OpenFileDialog();
            openFileDialog.Multiselect = true;
            openFileDialog.CheckFileExists = true;
            switch (parameter.ToString())
            {
                case "Import ACAS":
                    {
                        IngestAcas();
                        break;
                    }
                case "Import CKL":
                    {
                        IngestCkl();
                        break;
                    }
                case "Import WASSP":
                    {
                        IngestWassp();
                        break;
                    }
                case "Import XCCDF":
                    {
                        IngestXccdf();
                        break;
                    }
                case "Import Fortify":
                    {
                        IngestFortify();
                        break;
                    }
                default:
                    { break; }
            }
            openFileDialog = null;
        }

        private void IngestAcas()
        {
            try
            {
                openFileDialog.Filter = "ACAS Files (*.csv;*.nessus)|*.csv;*.nessus";
                openFileDialog.Title = "Please select ACAS file(s)";
                openFileDialog.ShowDialog();
                if (openFileDialog.FileNames.Length > 0)
                {
                    for (int i = 0; i < openFileDialog.FileNames.Length; i++)
                    {
                        string filePath = openFileDialog.FileNames[i];
                        string fileName = Path.GetFileNameWithoutExtension(filePath);
                        if (Path.GetExtension(filePath).ToLower().Equals(".nessus"))
                        { IngestedFiles.Add(new Model.Object.File(fileName, "ACAS - Nessus", "Ready", string.Empty, filePath, "True")); }
                        else
                        { IngestedFiles.Add(new Model.Object.File(fileName, "ACAS - CSV", "Ready", string.Empty, filePath, "True")); }
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error("Unable to retrieve ACAS file(s).");
                log.Debug("Exception details: " + exception);
            }
        }

        private void IngestCkl()
        {
            try
            {
                openFileDialog.Filter = "CKL Files (*.ckl)|*.ckl";
                openFileDialog.Title = "Please select CKL file(s)";
                openFileDialog.ShowDialog();
                if (openFileDialog.FileNames.Length > 0)
                {
                    for (int i = 0; i < openFileDialog.FileNames.Length; i++)
                    {
                        string filePath = openFileDialog.FileNames[i];
                        string fileName = Path.GetFileNameWithoutExtension(filePath);
                        CklReader cklReader = new CklReader();
                        Model.Object.File file = new Model.Object.File(fileName, "Checklist", "Ready", string.Empty, filePath, "True");
                        file = cklReader.ObtainIdentifiers(file);
                        IngestedFiles.Add(file);
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error("Unable to retrieve CKL file(s).");
                log.Debug("Exception details: " + exception);
            }
        }

        private void IngestWassp()
        {
            try
            {
                openFileDialog.Filter = "WASSP Files (*.html)|*.html;*.xml";
                openFileDialog.Title = "Please select WASSP file(s)";
                openFileDialog.ShowDialog();
                if (openFileDialog.FileNames.Length > 0)
                {
                    for (int i = 0; i < openFileDialog.FileNames.Length; i++)
                    {
                        string filePath = openFileDialog.FileNames[i];
                        string fileName = Path.GetFileNameWithoutExtension(filePath);
                        if (Path.GetExtension(filePath).ToLower().Equals(".html"))
                        { IngestedFiles.Add(new Model.Object.File(fileName, "WASSP - HTML", "Ready", string.Empty, filePath, "True")); }
                        else
                        { IngestedFiles.Add(new Model.Object.File(fileName, "WASSP - XML", "Ready", string.Empty, filePath, "True")); }
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error("Unable to retrieve WASSP file(s).");
                log.Debug("Exception details: " + exception);
            }
        }

        private void IngestXccdf()
        {
            try
            {
                openFileDialog.Filter = "XCCDF Files (*.xml)|*.xml";
                openFileDialog.Title = "Please select XCCDF file(s)";
                openFileDialog.ShowDialog();
                if (openFileDialog.FileNames.Length > 0)
                {
                    for (int i = 0; i < openFileDialog.FileNames.Length; i++)
                    {
                        string filePath = openFileDialog.FileNames[i];
                        string fileName = Path.GetFileNameWithoutExtension(filePath);
                        IngestedFiles.Add(new Model.Object.File(fileName, "SCAP Benchmark", "Ready", string.Empty, filePath, "True"));
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error("Unable to retrieve XCCDF file(s).");
                log.Debug("Exception details: " + exception);
            }
        }

        private void IngestFortify()
        {
            try
            {
                openFileDialog.Filter = "Fortify FPR Files (*.fpr)|*.fpr";
                openFileDialog.Title = "Please select Fortify file(s)";
                openFileDialog.ShowDialog();
                if (openFileDialog.FileNames.Length > 0)
                {
                    for (int i = 0; i < openFileDialog.FileNames.Length; i++)
                    {
                        string filePath = openFileDialog.FileNames[i];
                        string fileName = Path.GetFileNameWithoutExtension(filePath);
                        IngestedFiles.Add(new Model.Object.File(fileName, "Fortify FPR", "Ready", string.Empty, filePath, "True"));
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error("Unable to retrieve FPR file(s).");
                log.Debug("Exception details: " + exception);
            }
        }

        public RelayCommand ExecuteIngestionCommand
        { get { return new RelayCommand(ExecuteIngestion); } }

        private void ExecuteIngestion()
        {
            backgroundWorker = new BackgroundWorker();
            backgroundWorker.DoWork += ExecuteIngestionBackgroundWorker_DoWork;
            backgroundWorker.RunWorkerAsync();
            backgroundWorker.Dispose();
        }

        private void ExecuteIngestionBackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            GuiFeedback guiFeedback = new GuiFeedback();

            if (IngestedFiles.Count > 0)
            { ParseFiles(guiFeedback); }
            else
            {
                guiFeedback.SetFields("No files to process", "Collapsed", true);
                Messenger.Default.Send(guiFeedback);
                return;
            }

            stopWatch.Stop();
            log.Info("File ingestion complete; Elapsed time: " + stopWatch.Elapsed.ToString());
            stopWatch.Reset();
            guiFeedback.SetFields("File ingestion complete", "Collapsed", true);
            Messenger.Default.Send(guiFeedback);
        }

        private void ParseFiles(GuiFeedback guiFeedback)
        {
            guiFeedback.SetFields("Processing Files...", "Visible", false);
            Messenger.Default.Send(guiFeedback);
            stopWatch.Start();
            DropDatabaseIndexes();
            foreach (Model.Object.File file in IngestedFiles)
            {
                fileStopWatch.Start();
                file.Status = "Processing...";
                guiFeedback.ProgressLabelText = "Processing File " + (IngestedFiles.IndexOf(file) + 1).ToString() + "...";
                Messenger.Default.Send(guiFeedback);
                log.Info("Begin processing of " + file.FileName);
                switch (file.FileType)
                {
                    case "ACAS - CSV":
                        {
                            AcasCsvReader acasCsvReader = new AcasCsvReader();
                            file.Status = acasCsvReader.ReadAcasCsvFile(file);
                            break;
                        }
                    case "ACAS - Nessus":
                        {
                            AcasNessusReader acasNessusReader = new AcasNessusReader();
                            file.Status = acasNessusReader.ReadAcasNessusFile(file);
                            acasNessusReader = null;
                            break;
                        }
                    case "Checklist":
                        {
                            CklReader cklReader = new CklReader();
                            file.Status = cklReader.ReadCklFile(file);
                            break;
                        }
                    case "WASSP - HTML":
                        {
                            WasspReader wasspReader = new WasspReader();
                            file.Status = wasspReader.ReadWassp(file);
                            break;
                        }
                    case "WASSP - XML":
                        {
                            XmlWasspReader xmlWasspReader = new XmlWasspReader();
                            file.Status = xmlWasspReader.ReadXmlWassp(file);
                            break;
                        }
                    case "SCAP Benchmark":
                        {
                            XccdfReader xccdfReader = new XccdfReader();
                            file.Status = xccdfReader.ReadXccdfFile(file);
                            break;
                        }
                    case "Fortify FPR":
                        {
                            FprReader fprReader = new FprReader();
                            file.Status = fprReader.ReadFpr(file);
                            break;
                        }
                    default:
                        {
                            log.Error(file.FileName + " file type is unrecognized.");
                            break;
                        }
                }
                fileStopWatch.Stop();
                if (file.Status.Equals("Processed"))
                { log.Info(file.FileName + " successfully processed; Elapsed time: " + fileStopWatch.Elapsed.ToString()); }
                else
                { log.Error(file.FileName + " processing failed; Elapsed time: " + fileStopWatch.Elapsed.ToString()); }
                fileStopWatch.Reset();
            }
        }

        private void DropDatabaseIndexes()
        { 
            try
            {
                if (!DatabaseBuilder.sqliteConnection.State.ToString().Equals("Open"))
                { DatabaseBuilder.sqliteConnection.Open(); }
                using (SQLiteCommand sqliteCommand = DatabaseBuilder.sqliteConnection.CreateCommand())
                {
                    SQLiteCommand clonedCommand = sqliteCommand.Clone() as SQLiteCommand;
                    sqliteCommand.CommandText = Properties.Resources.SelectIndexes;
                    using (SQLiteDataReader sqliteDataReader = sqliteCommand.ExecuteReader())
                    {
                        if (!sqliteDataReader.HasRows)
                        { return; }
                        while (sqliteDataReader.Read())
                        {
                            if (sqliteDataReader["name"].ToString().Contains("autoindex"))
                            { continue; }
                            clonedCommand.CommandText = string.Format("DROP INDEX {0};", sqliteDataReader["name"].ToString());
                            clonedCommand.ExecuteNonQuery();
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                log.Error(string.Format("Unable to drop database indexes."));
                log.Debug("Exception details:", exception);
                throw exception;
            }
            finally
            { DatabaseBuilder.sqliteConnection.Close(); }
        }

        private bool ExcelReportsAreRequired()
        {
            bool PoamAndRarAreNeeded = bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbPoamRar"));
            bool SummaryTabIsNeeded = bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbAssetOverview"));
            bool DiscrepanciesTabIsNeeded = bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbDiscrepancies"));
            bool AcasOutputTabIsNeeded = bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbAcasOutput"));
            bool StigDetailsTabIsNeeded = bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbStigDetails"));
            if (PoamAndRarAreNeeded || SummaryTabIsNeeded || DiscrepanciesTabIsNeeded || AcasOutputTabIsNeeded || StigDetailsTabIsNeeded)
            { return true; }
            else
            { return false; }
        }

        private bool? GetExcelReportName()
        {
            saveExcelFile = new SaveFileDialog();
            saveExcelFile.AddExtension = true;
            saveExcelFile.Filter = "Excel Files (*.xlsx)|*.xlsx";
            saveExcelFile.DefaultExt = "xlsx";
            saveExcelFile.Title = "Save Excel Report";
            saveExcelFile.OverwritePrompt = true;
            saveExcelFile.CheckPathExists = true;
            return saveExcelFile.ShowDialog();
        }

        private string CreateExcelReports()
        {
            log.Info("Begin creation of " + saveExcelFile.FileName);
            fileStopWatch.Start();
            OpenXmlReportCreator openXmlReportCreator = new OpenXmlReportCreator();
            if (!openXmlReportCreator.CreateExcelReport(saveExcelFile.FileName).Contains("successful"))
            {
                log.Error("Creation of " + saveExcelFile.FileName + " failed; Elapsed time: " + fileStopWatch.Elapsed.ToString());
                fileStopWatch.Stop();
                fileStopWatch.Reset();
                return "Excel report creation error; see log for details";
            }
            else
            {
                log.Info(saveExcelFile.FileName + " created successfully; Elapsed time: " + fileStopWatch.Elapsed.ToString());
                fileStopWatch.Stop();
                fileStopWatch.Reset();
                return "Excel report created successfully";
            }
        }

        private bool PdfReportIsRequired()
        {
            if (bool.Parse(ConfigAlter.ReadSettingsFromDictionary("cbPdfSum")))
            { return true; }
            else
            { return false; }
        }

        private bool? GetPdfReportName()
        {
            savePdfFile = new SaveFileDialog();
            savePdfFile.AddExtension = true;
            savePdfFile.Filter = "PDF Files (*.pdf)|*.pdf";
            savePdfFile.DefaultExt = "xls";
            savePdfFile.Title = "Save PDF Report";
            savePdfFile.OverwritePrompt = true;
            savePdfFile.CheckPathExists = true;
            return savePdfFile.ShowDialog();
        }

        private string CreatePdfReport()
        {
            log.Info("Begin creation of " + savePdfFile.FileName);
            fileStopWatch.Start();
            PdfReportCreator pdfReportCreator = new PdfReportCreator();
            if (!pdfReportCreator.PdfWriter(savePdfFile.FileName.ToString(), string.Empty).Equals("Success"))
            {
                log.Error("Creation of " + savePdfFile.FileName + " failed; Elapsed time: " + fileStopWatch.Elapsed.ToString());
                fileStopWatch.Stop();
                fileStopWatch.Reset();
                return "PDF report creation error; see log for details";
            }
            else
            {
                log.Info(savePdfFile.FileName + " created successfully; Elapsed time: " + fileStopWatch.Elapsed.ToString());
                fileStopWatch.Stop();
                fileStopWatch.Reset();
                return "PDF summary created successfully";
            }
        }

        public RelayCommand ClearIngestedFilesCommand
        { get { return new RelayCommand(ClearIngestedFiles); } }

        private void ClearIngestedFiles()
        { IngestedFiles.Clear(); }

        public RelayCommand ExecuteExportCommand
        { get { return new RelayCommand(ExecuteExport); } }

        private void ExecuteExport()
        {
            backgroundWorker = new BackgroundWorker();
            backgroundWorker.DoWork += ExecuteExportBackgroundWorker_DoWork;
            backgroundWorker.RunWorkerAsync();
            backgroundWorker.Dispose();
        }

        private void ExecuteExportBackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        { 
            try
            {
                GuiFeedback guiFeedback = new GuiFeedback();
                guiFeedback.SetFields("Generating requested reports", "Visible", false);
                Messenger.Default.Send(guiFeedback);
                if (Properties.Settings.Default.ReportPoamRar)
                {
                    if ((bool)GetExcelReportName())
                    {
                        OpenXmlReportCreator openXmlReportCreator = new OpenXmlReportCreator();
                        openXmlReportCreator.CreateExcelReport(saveExcelFile.FileName);
                    }
                }
                guiFeedback.SetFields("Report creation complete", "Collapsed", true);
                Messenger.Default.Send(guiFeedback);
            }
            catch (Exception exception)
            {
                log.Error(string.Format("Unable to export the requested reports."));
                log.Debug("Exception details:", exception);
                throw exception;
            }
        }
    }
}
